
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GoFigure Equation Solver</title>
    <!-- Load Tailwind CSS CDN for modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Lucide Icons -->
    <link href="https://cdn.jsdelivr.net/npm/lucide-static@latest/font/lucide.css" rel="stylesheet">
    
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0fdfa; /* Teal-50 background */
        }
        .lucide {
            display: inline-block;
            width: 1em;
            height: 1em;
            stroke-width: 2;
            stroke: currentColor;
            fill: none;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        /* --- Equation Row Styling --- */
        #equation-area {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
        }
        .box {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 6px;
            font-weight: bold;
            font-size: 1.25rem;
            transition: background-color 0.2s, border-color 0.2s;
        }
        
        .number-slot {
            background-color: #e0f2f1; /* Teal-100 */
            border: 2px dashed #0d9488; /* Teal-600 */
        }
        .operator-slot {
            background-color: #f0fdfa; /* Teal-50 */
            border: 2px dashed #14b8a6; /* Teal-500 */
        }
        .number-slot.active, .operator-slot.active {
            background-color: #99f6e4; /* Teal-200 */
        }

        /* --- Tile Styling (Draggable) --- */
        .puzzle-tile {
            width: 90%;
            height: 90%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.4rem;
            font-weight: 800;
            color: #ffffff;
            border-radius: 4px;
            box-shadow: 0 3px #134e4a; /* Darker shadow */
            cursor: grab;
            transition: transform 0.1s ease-out, box-shadow 0.1s ease-out;
        }
        .puzzle-tile:active {
            box-shadow: 0 1px #134e4a;
            transform: translateY(2px);
            cursor: grabbing;
        }

        .number-tile {
            background-color: #0d9488; /* Teal-600 */
        }
        .operator-tile {
            background-color: #3b82f6; /* Blue-500 */
        }
        
        /* --- Utilities --- */
        .flex-grow-0 { flex-grow: 0; }
        .hidden { display: none !important; }

    </style>
</head>
<body class="min-h-screen flex flex-col items-center justify-center p-4">

    <!-- Main Game Container -->
    <div id="game-container" class="w-full max-w-md bg-white p-6 md:p-8 rounded-2xl shadow-2xl border-t-8 border-teal-500">
        
        <header class="text-center mb-6">
            <h1 class="text-3xl font-extrabold text-teal-700">GoFigure! Equation Solver</h1>
            <p class="text-md text-gray-500 font-medium">Use the numbers and operators exactly once to hit the target.</p>
        </header>

        <!-- Equation Area -->
        <div id="equation-area" class="mb-8">
            <!-- Boxes inserted by JS (N op N op N op N) -->
            <span class="text-2xl font-extrabold text-teal-700">=</span>
            <span id="target-value" class="text-3xl font-extrabold text-teal-900 ml-2">1</span>
        </div>

        <!-- Tile Pool -->
        <div id="tile-pool" class="flex flex-wrap justify-center gap-4 mb-6 p-4 bg-teal-50 rounded-xl shadow-md border border-teal-200">
            <!-- Draggable tiles inserted by JS -->
        </div>

        <!-- Controls and Status -->
        <div class="flex flex-col space-y-4">
            <div id="message-box" class="min-h-14 p-3 rounded-xl text-center font-bold flex items-center justify-center transition-colors duration-200 text-gray-700 bg-gray-50 border">
                Drag tiles into the empty slots.
            </div>
            
            <button
                id="check-btn"
                class="w-full py-3 bg-teal-600 text-white rounded-xl text-xl font-extrabold hover:bg-teal-700 shadow-lg transition duration-150 flex items-center justify-center"
            >
                <i class="lucide lucide-shield-check w-6 h-6 mr-2"></i> Check Equation
            </button>
            
            <button
                id="reset-btn"
                class="w-full py-3 bg-red-500 text-white rounded-xl text-lg font-extrabold hover:bg-red-600 shadow-md transition duration-150 flex items-center justify-center"
            >
                <i class="lucide lucide-rotate-ccw w-5 h-5 mr-2"></i> Next Puzzle
            </button>
        </div>
    </div>

    <script>
        // --- Puzzle Data (Based on image format) ---
        // Format: [N1, N2, N3, N4], Target
        const PUZZLE_SETS = [
            // Easy: [3, 3, 8, 9] = 1
            { numbers: [3, 3, 8, 9], target: 1, difficulty: "Easy" }, 
            // Medium: [4, 6, 8, 9] = 27
            { numbers: [4, 6, 8, 9], target: 27, difficulty: "Medium" }, 
            // Hard: [4, 4, 7, 9] = 8
            { numbers: [4, 4, 7, 9], target: 8, difficulty: "Hard" },
        ];

        const OPERATORS = ['+', '-', '*', '/'];

        // --- Global State ---
        let currentPuzzleIndex = 0;
        let currentNumbers = [];
        let currentTarget = 0;
        
        // This array represents the 7 slots in the equation: [N1, op1, N2, op2, N3, op3, N4]
        let equationSlots = new Array(7).fill(null);
        
        // Tracks which tiles are currently placed in the equation
        let placedTiles = {}; // Key: "number-N" or "operator-OP", Value: slotIndex

        // --- DOM Elements ---
        const equationArea = document.getElementById('equation-area');
        const tilePool = document.getElementById('tile-pool');
        const messageBox = document.getElementById('message-box');
        const targetValueSpan = document.getElementById('target-value');
        const checkBtn = document.getElementById('check-btn');
        const resetBtn = document.getElementById('reset-btn');

        // --- Utility Functions ---

        const clearMessage = (text = 'Drag tiles into the empty slots.') => {
            messageBox.innerHTML = text;
            messageBox.className = 'min-h-14 p-3 rounded-xl text-center font-bold flex items-center justify-center transition-colors duration-200 text-gray-700 bg-gray-50 border';
        };
        
        // --- Drag and Drop Handlers ---
        
        let draggedData = {
            tileType: null, // 'number' or 'operator'
            tileValue: null,
            sourceKey: null, // "POOL" or slotIndex
        };

        function handleDragStart(e, type, value, sourceKey) {
            draggedData = { tileType: type, tileValue: value, sourceKey: sourceKey };
            e.dataTransfer.setData('text/plain', value);
            e.dataTransfer.effectAllowed = 'move';
            e.target.classList.add('opacity-50');
        }

        function handleDragOver(e) {
            e.preventDefault(); 
            const slotIndex = parseInt(e.currentTarget.dataset.index);
            
            // Allow drop only if the slot type matches the dragged tile type
            const isNumberSlot = slotIndex % 2 === 0;
            const isOperatorSlot = slotIndex % 2 !== 0;

            if ((isNumberSlot && draggedData.tileType === 'number') || 
                (isOperatorSlot && draggedData.tileType === 'operator')) {
                e.dataTransfer.dropEffect = 'move';
                e.currentTarget.classList.add('active'); // Visual feedback
            } else {
                e.dataTransfer.dropEffect = 'none';
            }
        }
        
        function handleDragLeave(e) {
            e.currentTarget.classList.remove('active');
        }

        function handleDrop(e, targetSlotIndex) {
            e.preventDefault();
            e.currentTarget.classList.remove('active'); // Remove visual feedback
            
            const tileKey = `${draggedData.tileType}-${draggedData.tileValue}`;
            
            // 1. Handle source cleanup (if moving from a slot)
            if (draggedData.sourceKey !== "POOL") {
                const oldSlotIndex = parseInt(draggedData.sourceKey);
                // Clear the old slot
                equationSlots[oldSlotIndex] = null;
                delete placedTiles[tileKey];
            }

            // 2. Handle target placement
            const tileInTarget = equationSlots[targetSlotIndex];
            
            // If the target slot already had a tile, return it to the pool
            if (tileInTarget) {
                // Find the existing tile's key (e.g., "number-5" or "operator-*")
                let existingTileKey;
                if (targetSlotIndex % 2 === 0) { // Number slot
                    existingTileKey = `number-${tileInTarget}`;
                } else { // Operator slot
                    existingTileKey = `operator-${tileInTarget}`;
                }
                
                // Return the physical tile element to the pool
                const tileToReturn = document.querySelector(`.puzzle-tile[data-key="${existingTileKey}"]`);
                if (tileToReturn) {
                    tilePool.appendChild(tileToReturn);
                    tileToReturn.classList.remove('hidden');
                    // Clear tile's slot reference
                    if (placedTiles[existingTileKey] !== undefined) {
                        delete placedTiles[existingTileKey];
                    }
                }
            }
            
            // Place the new tile in the equation slot array
            equationSlots[targetSlotIndex] = draggedData.tileValue;
            placedTiles[tileKey] = targetSlotIndex;

            // 3. Move the dragged tile into the slot's element
            const draggedTile = document.querySelector(`.puzzle-tile[data-key="${tileKey}"]`);
            if (draggedTile) {
                // Hide the tile in the pool (it's now in the slot)
                draggedTile.classList.add('hidden');
                
                // Update the slot content directly
                const targetSlotElement = document.querySelector(`.box[data-index="${targetSlotIndex}"]`);
                targetSlotElement.textContent = draggedData.tileValue;
                targetSlotElement.style.backgroundColor = draggedData.tileType === 'number' ? '#0d9488' : '#3b82f6';
                targetSlotElement.style.color = '#fff';
            }
            
            clearMessage();
            checkProgress();
        }

        function handleDragEnd(e) {
            e.target.classList.remove('opacity-50');
            // Re-render to ensure visual state is correct
            renderEquationArea();
            renderTilePool();
        }

        // --- Core Game Functions ---

        function startGame() {
            const puzzle = PUZZLE_SETS[currentPuzzleIndex % PUZZLE_SETS.length];
            currentNumbers = puzzle.numbers;
            currentTarget = puzzle.target;
            equationSlots.fill(null);
            placedTiles = {};
            targetValueSpan.textContent = currentTarget;
            
            renderEquationArea();
            renderTilePool();
            clearMessage(`Welcome! Difficulty: ${puzzle.difficulty}. Drag tiles to solve the equation.`);
        }

        function renderEquationArea() {
            equationArea.innerHTML = '';
            
            // The equation is N op N op N op N = Target (7 boxes)
            for (let i = 0; i < 7; i++) {
                const value = equationSlots[i];
                const isNumberSlot = i % 2 === 0;
                const slotTypeClass = isNumberSlot ? 'number-slot' : 'operator-slot';
                
                let content = '';
                let bgColor = '';
                let textColor = 'transparent';
                
                if (value !== null) {
                    content = value;
                    bgColor = isNumberSlot ? '#0d9488' : '#3b82f6';
                    textColor = '#fff';
                } else {
                    content = ' ';
                    bgColor = ''; // Defined by CSS classes
                    textColor = '';
                }

                const dropListeners = `
                    ondragover="handleDragOver(event)" 
                    ondragleave="handleDragLeave(event)" 
                    ondrop="handleDrop(event, ${i})"
                `;
                
                equationArea.innerHTML += `
                    <div 
                        class="box ${slotTypeClass}" 
                        data-index="${i}" 
                        style="background-color: ${bgColor}; color: ${textColor};"
                        ${dropListeners}
                    >
                        ${content}
                    </div>
                `;
            }
            equationArea.innerHTML += `
                <span class="text-2xl font-extrabold text-teal-700 ml-2">=</span>
                <span id="target-value" class="text-3xl font-extrabold text-teal-900">${currentTarget}</span>
            `;
            
            // Ensure target is correctly updated if rendering separately
            const updatedTargetSpan = document.getElementById('target-value');
            if (updatedTargetSpan) {
                updatedTargetSpan.textContent = currentTarget;
            }
        }

        function renderTilePool() {
            tilePool.innerHTML = '';
            
            // 1. Render Number Tiles
            currentNumbers.forEach((num, index) => {
                const tileKey = `number-${num}-${index}`; // Use index for unique identification
                const isPlaced = Object.keys(placedTiles).includes(`number-${num}`); // Simpler check for now, assumes all numbers are unique
                
                const tile = document.createElement('div');
                tile.textContent = num;
                tile.className = `puzzle-tile number-tile ${isPlaced ? 'hidden' : 'flex-grow-0'}`;
                tile.setAttribute('data-key', tileKey);
                tile.setAttribute('data-value', num);
                tile.setAttribute('draggable', 'true');
                tile.setAttribute('ondragstart', `handleDragStart(event, 'number', ${num}, 'POOL')`);
                tile.setAttribute('ondragend', 'handleDragEnd(event)');
                tilePool.appendChild(tile);
            });
            
            // 2. Render Operator Tiles
            OPERATORS.forEach(op => {
                const tileKey = `operator-${op}`;
                const isPlaced = Object.keys(placedTiles).includes(tileKey);
                
                const tile = document.createElement('div');
                tile.textContent = op;
                tile.className = `puzzle-tile operator-tile ${isPlaced ? 'hidden' : 'flex-grow-0'}`;
                tile.setAttribute('data-key', tileKey);
                tile.setAttribute('data-value', op);
                tile.setAttribute('draggable', 'true');
                tile.setAttribute('ondragstart', `handleDragStart(event, 'operator', '${op}', 'POOL')`);
                tile.setAttribute('ondragend', 'handleDragEnd(event)');
                tilePool.appendChild(tile);
            });
        }
        
        function evaluateEquation() {
            // Check if all slots are filled
            if (equationSlots.some(slot => slot === null)) {
                return { result: NaN, isComplete: false };
            }
            
            const [N1, op1, N2, op2, N3, op3, N4] = equationSlots;
            
            // Create a string expression: N1 op1 N2 op2 N3 op3 N4
            const expression = `${N1} ${op1} ${N2} ${op2} ${N3} ${op3} ${N4}`;
            
            // Note: Using eval is generally unsafe in production, but acceptable for a simple math puzzle 
            // where input is controlled. We must handle division by zero and non-integer results.
            try {
                // Ensure floating point numbers are allowed but only if the target allows it.
                // The current puzzle set only uses integers, so we round to handle float arithmetic errors.
                let result = eval(expression);

                // For integer puzzles, check if the result is close enough to an integer.
                // If it's pure division, the result may be a float. We assume standard order of operations (BODMAS/PEMDAS).

                return { result: result, isComplete: true };

            } catch (e) {
                // Catches syntax errors or division by zero (if eval is smart)
                return { result: NaN, isComplete: true, error: e.message };
            }
        }

        function checkProgress() {
            const { result, isComplete, error } = evaluateEquation();

            if (!isComplete) {
                clearMessage(`Place all numbers (4) and operators (3) to check the solution.`);
                return;
            }
            
            if (error) {
                messageBox.innerHTML = `<div class="flex items-center justify-center text-xl text-yellow-700 bg-yellow-100 rounded-lg p-2">
                    <i class="lucide lucide-frown w-6 h-6 mr-2"></i> Error in equation: ${error}. Check your operators.
                </div>`;
                messageBox.className = 'min-h-14 p-0 rounded-xl text-center font-bold flex items-center justify-center transition-colors duration-200';
                return;
            }

            // Check if the result is exactly equal to the target
            const isCorrect = Math.abs(result - currentTarget) < 0.0001; // Use epsilon for floating point safety

            if (isCorrect) {
                messageBox.innerHTML = `<div class="flex items-center justify-center text-2xl text-white bg-green-600 rounded-lg p-2">
                    <i class="lucide lucide-party-popper w-7 h-7 mr-2"></i> Correct! ${result} = ${currentTarget}
                </div>`;
                messageBox.className = 'min-h-14 p-0 rounded-xl text-center font-bold flex items-center justify-center transition-colors duration-200';
            } else {
                messageBox.innerHTML = `<div class="flex items-center justify-center text-xl text-red-700 bg-red-100 rounded-lg p-2">
                    <i class="lucide lucide-x-octagon w-6 h-6 mr-2"></i> Incorrect. Equation evaluates to ${result}. Target is ${currentTarget}.
                </div>`;
                messageBox.className = 'min-h-14 p-0 rounded-xl text-center font-bold flex items-center justify-center transition-colors duration-200';
            }
        }
        
        function handleNextPuzzle() {
            currentPuzzleIndex++;
            startGame();
        }

        // --- Event Listeners and Initialization ---

        checkBtn.addEventListener('click', checkProgress);
        resetBtn.addEventListener('click', handleNextPuzzle);
        window.addEventListener('dragend', handleDragEnd); // Global dragend handler

        window.onload = startGame;
        
    </script>
</body>
</html>
